\setcounter{page}{1}

\chapter*{Introdução}\label{cap:introducao}
\addcontentsline{toc}{chapter}{Introdução}
\mychaptermark{Introdução}

Quem, em computação, nunca ouviu a frase - "use essa linguagem que vai ser mais fácil de implementar esse algoritmo". Se comparada à visão teórica de computação, essa afirmação pode parecer sem fundamento, afinal todas as linguagens que são Turing-completo~\cite{sipser2006introduction} permitem escrever os mesmos algoritmos e todas elas têm a mesma capacidade de representação. Também temos a tese de Church-Turing definindo que se uma função pode ser implementada por uma linguagem de programação, todas as demais linguagens de programação também podem implementar a mesma função~\cite{copeland2007church}. Então como pode ser melhor usar uma linguagem do que outra para implementar um determinado algoritmo, se as linguagens modernas são todas Turing-completas?

A escolha da linguagem é uma questão de estilo e da adaptação dela ao contexto do algoritmo implementado. Quanto mais próximas forem as abstrações fornecidas pelas linguagens dos algoritmos implementados com elas, menos complexas serão essas implementações~\cite{fowler2010domain}. Isso é motivação suficiente para o projeto contínuo de novas linguagens e para o aperfeiçoamento das linguagens existentes. Para flexibilizar essas adaptações aos domínios de aplicação, as linguagens modernas têm incorporado conceitos que permitem definir nos programas não somente como será a sua execução, mas também como será sua compilação e interpretação. Isso possibilita adaptar a compilação e interpretação para atender melhor as necessidades de cada aplicação.

Os compiladores e interpretadores têm geralmente etapas de execução definidas e únicas para qualquer aplicação que será compilada ou interpretada. Essas etapas podem, em determinados casos, tornar o desenvolvimento de uma aplicação mais complexo por conta das características inerentes a elas. As linguagens que têm incorporado funcionalidades para permitir aos programas redefinir, remover e adicionar novos comportamentos às etapas de compilação e interpretação, acabam por tornar o desenvolvimento dos programas menos complexo. Isso acontece porque os algoritmos que eram amarrados a comportamentos fixos de compilação e interpretação, agora podem adaptar etapas para que sejam mais adequadas a eles.

Não é novidade permitir que etapas fixas sejam adaptadas, esse é o caminho convencional de muitos conceitos em computação. Um paralelo pode ser feito com as bibliotecas de computação gráfica~\cite{rost2009opengl}, no início elas tinham um fluxo de execução fixo que passou a ser adaptável conforme as bibliotecas evoluíam (\emph{Shading Language}). Com as linguagens de programação não é diferente, no início elas tinham compiladores e interpretadores com etapas fixas e com o tempo passaram a ser mais flexíveis. Em ambos os casos foram criados mecanismos que permitiram usar as bibliotecas gráficas e as linguagens de programação para interagir com características vinculadas a elas próprias. No domínio das linguagens de programação, essa mecânica é chamada de metaprogramação e permite que as linguagens de programação definam funcionalidades a respeito de sua própria compilação, interpretação e execução.

O conceito de metaprogramação não é utilizado em um único contexto, por isso a metaprogramação não possui somente uma definição. Ela pode ser apresentada de modo diferente dependendo do contexto em que estiver sendo utilizada~\cite{damavsevivcius2015taxonomy}. Nessa pesquisa estamos interessados na definição de metaprogramação em tempo de compilação e não trataremos as demais formas de metaprogramação. A metaprogramação em compilação permite definir comportamentos não convencionais que o compilador pode executar dependendo do código-fonte que estiver compilando.

Por exemplo, em compilação usando metaprogramação, é possível adicionar uma funcionalidade ao compilador, para que toda vez que ele encontre uma função que retorna um valor de algum tipo específico, ele adicione antes desse retorno uma chamada de função que verifique se o valor retornado passa por uma validação respeitando um predicado. A chamada de função que foi adicionada pode de modo similar ser feita usando orientação a aspectos, que permite localizar pontos do código-fonte e realizar chamadas de funções nesses locais~\cite{kiczales1997aspect}. Aplicações orientadas a aspectos usam desse tipo de implementação para separar os requisitos funcionais dos não funcionais e tornar o código-fonte melhor organizado. 

Nessa pesquisa mostramos como a metaprogramação pode ser utilizada para separar requisitos não funcionais de modo diferente do que é feito usando orientação a aspectos. Ao contrário da orientação a aspectos, a metaprogramação possibilita explorar o código-fonte de forma mais abrangente, o que torna possível separar os requisitos não funcionais e verificar se o código-fonte respeita restrições impostas por esses requisitos. Essa verificação é uma tarefa que usando orientação a aspectos é bem mais difícil de realizar.

Essa pesquisa não usou orientação a aspectos em momento algum. A associação entre essa pesquisa e a orientação a aspectos está no problema que ambas resolvem. Esse problema é a separação do código-fonte dos requisitos funcionais do código-fonte dos requisitos não funcionais~\cite{glinz2007non}.

O requisito não funcional de redundância pode ser implementado em diferentes aplicações sem estar relacionado ao comportamento principal de cada uma delas. Uma aplicação que atenda a esse requisito se mantém disponível aos usuários mesmo que algum tipo de falha ocorra durante sua execução~\cite{cachin2011introduction}. As aplicações não redundantes se comportam de forma diferente, uma falha provavelmente fará com que essas aplicações se tornem indisponíveis para o usuário. Esse requisito não funcional foi selecionado para demonstrar como a metaprogramação permite separar dele o resto do código-fonte. Nesse caso prático, a metaprogramação também é usada para verificar o código-fonte procurando por restrições impostas pelo requisito de redundância da replicação.

Para implementar as aplicações redundantes foi usado o conceito de replicação. Cada aplicação replicada executa em mais de uma instância, assim se alguma instância falhar e parar de executar as outras podem manter a aplicação executando. Novas instâncias da mesma aplicação podem ser executadas a qualquer momento para recuperar uma instância que falhou. O mecanismo de replicação torna as aplicações redundantes. Ele também requer que as aplicações sejam implementadas de modo determinista. Essa restrição associada à replicação é verificada usando metaprogramação para evitar que as aplicações apresentem comportamentos não deterministas durante sua execução.

O comportamento determinista é aquele que, associado a uma condição inicial, sempre produzirá o mesmo resultado quando executado~\cite{wiesmann2000understanding}. Caso as instâncias executem um comportamento não determinista, mesmo que elas iniciem a execução a partir da mesma condição inicial, elas poderão obter resultados diferentes, tornando-se assim inconsistentes.

A linguagem de programação foco dessa pesquisa é Cyan, por fornecer suporte à metaprogramação em tempo de compilação e permitir integrar código-fonte Java em código-fonte Cyan com facilidade~\cite{guimaraes2013cyan}. Em Cyan, a metaprogramação é feita em Java e consiste na implementação de classes que herdam classes do compilador de Cyan e que podem estender suas interfaces. Esses metaobjetos são compilados para serem usados pelo compilador de Cyan durante determinadas etapas da compilação das aplicações desenvolvidas em Cyan.

O \emph{framework} Treplica foi utilizado para implementar o conceito de replicação~\cite{vieira08a}, ele é originalmente desenvolvido em Java e nessa pesquisa foi integrado em Cyan por meio de uma biblioteca desenvolvida em Cyan. Essa biblioteca cria uma casca para o código-fonte Java de Treplica, facilitando a implementação de aplicações de Cyan que usam Treplica. A metaprogramação foi utilizada para separar a biblioteca Treplica do restante da aplicação Cyan e para verificar se o código-fonte da aplicação possui comportamento não determinista. Caso o compilador encontre algum trecho de código-fonte não determinista, ele substituirá esse trecho por um código determinista e se ele não souber realizar essa substituição, ele retornará um erro de compilação.

O uso da metaprogramação no contexto da replicação acaba por reduzir os problemas de não determinismo inerentes a esse tipo de aplicação. Permitindo separar com maior transparência o código-fonte que implementa o mecanismo de replicação do restante da aplicação, reduzindo assim a complexidade do desenvolvimento das aplicações replicadas.

Como resultado da pesquisa foi possível diminuir a complexidade das aplicações replicadas, devido ao uso de metaprogramação. Essa abordagem de utilizar metaprogramação para isolar o requisito não funcional de redundância e a verificação do código-fonte na busca de erros associados a esse requisito é uma solução que pode ser estendida a outros requisitos não funcionais. Isso permite que essa pesquisa possa ser generalizada para outros contextos onde seja necessário separar requisitos não funcionais e garantir que o código-fonte atenda a determinadas restrições de programação.

Nos Capítulos~\ref{cap:metaprog} e~\ref{cap:replicacao} são tratados os conceitos usados nessa pesquisa. A linguagem de programação Cyan e seus mecanismos de metaprogramação são abordados com base em exemplos práticos, e o \emph{framework} Treplica é mostrado por meio de uma aplicação implementada em Java.

O Capítulo~\ref{cap:pesquisa} mostra como o \emph{framework} Treplica foi incorporado à linguagem de programação Cyan e como a metaprogramação foi utilizada para separar a replicação do restante do código-fonte da aplicação. Uma explicação sobre o problema de não determinismo também é apresentada neste capítulo. Ele termina explicando a implementação dos metaobjetos de Cyan que permitem o uso de Treplica de modo padronizado e transparente. 

No Capítulo~\ref{cap:estudo} são apresentados dois casos de uso de aplicações replicadas que foram implementadas usando metaprogramação. O primeiro é um jogo de tabuleiro para dois jogadores que usa replicação para permitir que cada jogador mantenha uma instância replicada do tabuleiro. O segundo exemplo trata de como os metaobjetos ajudam a evitar que os programas replicados criados sejam inconsistentes. No Apêndice~\ref{apd:metaobjetos} estão os códigos-fonte dos metaobjetos de Cyan desenvolvidos durante a realização dessa pesquisa.
 